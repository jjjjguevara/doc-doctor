//! Document Origin
//!
//! Describes how the document content was created.

use serde::{Deserialize, Deserializer};

/// Document origin - how the content was created
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Default)]
pub enum Origin {
    /// Created by human author
    #[default]
    Human,

    /// Generated by AI/LLM
    Ai,

    /// AI-generated with human editing
    AiAssisted,

    /// Imported from external source
    Imported,

    /// Derived/transformed from other documents
    Derived,

    /// Collaborative authorship
    Collaborative,
}

impl serde::Serialize for Origin {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        serializer.serialize_str(match self {
            Origin::Human => "human",
            Origin::Ai => "ai",
            Origin::AiAssisted => "ai_assisted",
            Origin::Imported => "imported",
            Origin::Derived => "derived",
            Origin::Collaborative => "collaborative",
        })
    }
}

impl<'de> Deserialize<'de> for Origin {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: Deserializer<'de>,
    {
        let s = String::deserialize(deserializer)?;
        Ok(match s.to_lowercase().as_str() {
            "human" => Origin::Human,
            "ai" => Origin::Ai,
            "ai_assisted" | "ai-assisted" => Origin::AiAssisted,
            "imported" => Origin::Imported,
            "derived" => Origin::Derived,
            "collaborative" => Origin::Collaborative,
            // Default to Human for unknown values
            _ => Origin::Human,
        })
    }
}

impl Origin {
    /// Get the display name for this origin
    pub const fn display_name(&self) -> &'static str {
        match self {
            Origin::Human => "Human-authored",
            Origin::Ai => "AI-generated",
            Origin::AiAssisted => "AI-assisted",
            Origin::Imported => "Imported",
            Origin::Derived => "Derived",
            Origin::Collaborative => "Collaborative",
        }
    }

    /// Get the trust factor for this origin (0.0-1.0)
    ///
    /// Higher values indicate more trusted sources.
    pub const fn trust_factor(&self) -> f64 {
        match self {
            Origin::Human => 0.9,
            Origin::Collaborative => 0.85,
            Origin::AiAssisted => 0.7,
            Origin::Imported => 0.6,
            Origin::Derived => 0.6,
            Origin::Ai => 0.5,
        }
    }

    /// Get all valid origin values
    pub const fn all() -> &'static [Origin] {
        &[
            Origin::Human,
            Origin::Ai,
            Origin::AiAssisted,
            Origin::Imported,
            Origin::Derived,
            Origin::Collaborative,
        ]
    }
}

impl std::fmt::Display for Origin {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", match self {
            Origin::Human => "human",
            Origin::Ai => "ai",
            Origin::AiAssisted => "ai_assisted",
            Origin::Imported => "imported",
            Origin::Derived => "derived",
            Origin::Collaborative => "collaborative",
        })
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_origin_display_name() {
        assert_eq!(Origin::Human.display_name(), "Human-authored");
        assert_eq!(Origin::Ai.display_name(), "AI-generated");
        assert_eq!(Origin::AiAssisted.display_name(), "AI-assisted");
    }

    #[test]
    fn test_trust_factors() {
        assert!(Origin::Human.trust_factor() > Origin::Ai.trust_factor());
        assert!(Origin::AiAssisted.trust_factor() > Origin::Ai.trust_factor());
    }

    #[test]
    fn test_serialization() {
        let origin = Origin::AiAssisted;
        let json = serde_json::to_string(&origin).unwrap();
        assert_eq!(json, r#""ai_assisted""#);

        let parsed: Origin = serde_json::from_str(&json).unwrap();
        assert_eq!(parsed, Origin::AiAssisted);
    }
}
